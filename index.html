<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Photo Generator</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0; background:#111; color:#eee; display:flex; flex-direction:column; height:100vh;}
  #ui { padding:12px; background:#0f1720; display:flex; gap:8px; align-items:center;}
  #canvas-wrap { flex:1; display:flex; align-items:center; justify-content:center; }
  canvas { width:100%; height:100%; display:block; }
  input[type=file] { color: #000; }
  button { padding:8px 12px; border-radius:6px; cursor:pointer; }
  .small { font-size:0.9rem; color:#bbb; }
  .alert { color: red; font-size: 0.8rem; }
</style>
</head>
<body>
  <div id="ui">
    <input id="file" type="file" accept="image/*">
    <label class="small"><input id="useDepth" type="checkbox"> 使用平滑深度</label>
    <button id="downloadPng">下载 PNG 快照</button>
    <button id="exportGlb">导出 GLB（3D）</button>
    <button id="exportWebm">导出微动画（WebM）</button>
    <div style="flex:1"></div>
    <div class="small">完全本地处理 · 不上传</div>
  </div>
  <div id="canvas-wrap"></div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/exporters/GLTFExporter.js';
  import { Segmentation } from 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js';

  const fileInput = document.getElementById('file');
  const downloadBtn = document.getElementById('downloadPng');
  const exportBtn = document.getElementById('exportGlb');
  const exportWebmBtn = document.getElementById('exportWebm');
  const useDepthCheckbox = document.getElementById('useDepth');
  const wrap = document.getElementById('canvas-wrap');

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 2.2);
  const renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, antialias: true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight - 64);
  wrap.appendChild(renderer.domElement);
  
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.maxDistance = 5;

  const light = new THREE.DirectionalLight(0xffffff, 1.0);
  light.position.set(0.5, 1, 1);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));

  let planeMesh;
  let depthMap, foregroundMap, backgroundMap;

  function onWindowResize() {
    renderer.setSize(window.innerWidth, window.innerHeight - 64);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onWindowResize);

  function generateDepthCanvas(img, smooth = false) {
    const c = document.createElement('canvas');
    const w = img.width, h = img.height;
    c.width = w;
    c.height = h;
    const ctx = c.getContext('2d');
    ctx.drawImage(img, 0, 0, w, h);
    const imgData = ctx.getImageData(0, 0, w, h);
    const data = ctx.createImageData(w, h);
    for (let i = 0; i < imgData.data.length; i += 4) {
      const r = imgData.data[i], g = imgData.data[i + 1], b = imgData.data[i + 2];
      const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      const depth = lum;
      data.data[i] = data.data[i + 1] = data.data[i + 2] = depth;
      data.data[i + 3] = 255;
    }
    ctx.putImageData(data, 0, 0);
    return c;
  }

  async function build3DFromImage(img, depthCanvas) {
    if (planeMesh) {
      scene.remove(planeMesh);
      planeMesh.geometry.dispose();
      planeMesh.material.dispose();
      planeMesh = null;
    }

    const tex = new THREE.Texture(img);
    tex.needsUpdate = true;
    const depthTex = new THREE.Texture(depthCanvas);
    depthTex.needsUpdate = true;

    const aspect = img.width / img.height;
    const geo = new THREE.PlaneGeometry(1.6 * aspect, 1.6, 256, 256);

    const mat = new THREE.ShaderMaterial({
      uniforms: {
        uMap: { value: tex },
        uDepth: { value: depthTex },
        uDepthScale: { value: 0.45 },
      },
      vertexShader: `
        varying vec2 vUv;
        uniform sampler2D uDepth;
        uniform float uDepthScale;
        void main() {
          vUv = uv;
          float d = texture2D(uDepth, uv).r;
          vec3 newPos = position + normal * (d * uDepthScale);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform sampler2D uMap;
        void main() {
          vec4 c = texture2D(uMap, vUv);
          gl_FragColor = c;
        }
      `,
      side: THREE.DoubleSide,
    });

    planeMesh = new THREE.Mesh(geo, mat);
    scene.add(planeMesh);
    camera.position.set(0, 0, 2.2);
    controls.update();
  }

  async function generateWebM() {
    const stream = renderer.domElement.captureStream(30);
    const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
    const chunks = [];

    recorder.ondataavailable = (event) => {
      chunks.push(event.data);
    };
    recorder.onstop = () => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'animation.webm';
      a.click();
    };

    recorder.start();
    setTimeout(() => recorder.stop(), 2000);
  }

  function downloadPNG() {
    const dataUrl = renderer.domElement.toDataURL('image/png');
    const a = document.createElement('a');
    a.download = '3d-photo.png';
    a.href = dataUrl;
    a.click();
  }

  function exportGLB() {
    if (!planeMesh) {
      alert('请先上传并生成 3D 照片');
      return;
    }
    const exporter = new GLTFExporter();
    exporter.parse(scene, (result) => {
      if (result instanceof ArrayBuffer) {
        saveArrayBuffer(result, '3d-photo.glb');
      } else {
        const str = JSON.stringify(result);
        const blob = new Blob([str], { type: 'application/json' });
        saveBlob(blob, '3d-photo.gltf');
      }
    }, { binary: true });
  }

  function saveBlob(blob, filename) {
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob
